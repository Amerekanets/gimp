/* The GIMP -- an image manipulation program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/* NOTE: This file is autogenerated by pdbgen.pl. */

#include "config.h"

#include <string.h>

#include <glib-object.h>

#include "libgimpcolor/gimpcolor.h"

#include "pdb-types.h"
#include "procedural_db.h"

#include "core/gimp.h"
#include "core/gimpcontext.h"
#include "core/gimpdatafactory.h"
#include "core/gimplist.h"
#include "core/gimppalette.h"

static ProcRecord palette_new_proc;
static ProcRecord palette_duplicate_proc;
static ProcRecord palette_rename_proc;
static ProcRecord palette_delete_proc;
static ProcRecord palette_is_editable_proc;
static ProcRecord palette_get_info_proc;
static ProcRecord palette_get_columns_proc;
static ProcRecord palette_set_columns_proc;
static ProcRecord palette_add_entry_proc;
static ProcRecord palette_delete_entry_proc;
static ProcRecord palette_entry_get_color_proc;
static ProcRecord palette_entry_set_color_proc;
static ProcRecord palette_entry_get_name_proc;
static ProcRecord palette_entry_set_name_proc;

void
register_palette_procs (Gimp *gimp)
{
  procedural_db_register (gimp, &palette_new_proc);
  procedural_db_register (gimp, &palette_duplicate_proc);
  procedural_db_register (gimp, &palette_rename_proc);
  procedural_db_register (gimp, &palette_delete_proc);
  procedural_db_register (gimp, &palette_is_editable_proc);
  procedural_db_register (gimp, &palette_get_info_proc);
  procedural_db_register (gimp, &palette_get_columns_proc);
  procedural_db_register (gimp, &palette_set_columns_proc);
  procedural_db_register (gimp, &palette_add_entry_proc);
  procedural_db_register (gimp, &palette_delete_entry_proc);
  procedural_db_register (gimp, &palette_entry_get_color_proc);
  procedural_db_register (gimp, &palette_entry_set_color_proc);
  procedural_db_register (gimp, &palette_entry_get_name_proc);
  procedural_db_register (gimp, &palette_entry_set_name_proc);
}

static Argument *
palette_new_invoker (ProcRecord   *proc_record,
                     Gimp         *gimp,
                     GimpContext  *context,
                     GimpProgress *progress,
                     Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gchar *actual_name = NULL;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  if (success)
    {
      if (strlen (name))
        {
          GimpData *data = gimp_data_factory_data_new (gimp->palette_factory, name);

          if (data)
            actual_name = g_strdup (gimp_object_get_name (GIMP_OBJECT (data)));
          else
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_pointer = actual_name;

  return return_args;
}

static ProcArg palette_new_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The requested name of the new palette"
  }
};

static ProcArg palette_new_outargs[] =
{
  {
    GIMP_PDB_STRING,
    "actual-name",
    "The actual new palette name"
  }
};

static ProcRecord palette_new_proc =
{
  "gimp-palette-new",
  "gimp-palette-new",
  "Creates a new palette",
  "This procedure creates a new, uninitialized palette",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  1,
  palette_new_inargs,
  1,
  palette_new_outargs,
  { { palette_new_invoker } }
};

static Argument *
palette_duplicate_invoker (ProcRecord   *proc_record,
                           Gimp         *gimp,
                           GimpContext  *context,
                           GimpProgress *progress,
                           Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gchar *copy_name = NULL;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette)
        {
          GimpPalette *palette_copy = (GimpPalette *)
            gimp_data_factory_data_duplicate (gimp->palette_factory,
                                              GIMP_DATA (palette));

          if (palette_copy)
            copy_name = g_strdup (gimp_object_get_name (GIMP_OBJECT (palette_copy)));
          else
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_pointer = copy_name;

  return return_args;
}

static ProcArg palette_duplicate_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  }
};

static ProcArg palette_duplicate_outargs[] =
{
  {
    GIMP_PDB_STRING,
    "copy-name",
    "The name of the palette's copy"
  }
};

static ProcRecord palette_duplicate_proc =
{
  "gimp-palette-duplicate",
  "gimp-palette-duplicate",
  "Duplicates a palette",
  "This procedure creates an identical palette by a different name",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  1,
  palette_duplicate_inargs,
  1,
  palette_duplicate_outargs,
  { { palette_duplicate_invoker } }
};

static Argument *
palette_rename_invoker (ProcRecord   *proc_record,
                        Gimp         *gimp,
                        GimpContext  *context,
                        GimpProgress *progress,
                        Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gchar *new_name;
  gchar *actual_name = NULL;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  new_name = (gchar *) args[1].value.pdb_pointer;
  if (new_name == NULL || !g_utf8_validate (new_name, -1, NULL))
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette && GIMP_DATA (palette)->writable)
        {
          gimp_object_set_name (GIMP_OBJECT (palette), new_name);
          actual_name = g_strdup (gimp_object_get_name (GIMP_OBJECT (palette)));
        }
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_pointer = actual_name;

  return return_args;
}

static ProcArg palette_rename_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_STRING,
    "new-name",
    "The new name of the palette"
  }
};

static ProcArg palette_rename_outargs[] =
{
  {
    GIMP_PDB_STRING,
    "actual-name",
    "The actual new name of the palette"
  }
};

static ProcRecord palette_rename_proc =
{
  "gimp-palette-rename",
  "gimp-palette-rename",
  "Rename a palette",
  "This procedure renames a palette",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  2,
  palette_rename_inargs,
  1,
  palette_rename_outargs,
  { { palette_rename_invoker } }
};

static Argument *
palette_delete_invoker (ProcRecord   *proc_record,
                        Gimp         *gimp,
                        GimpContext  *context,
                        GimpProgress *progress,
                        Argument     *args)
{
  gboolean success = TRUE;
  gchar *name;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette && GIMP_DATA (palette)->deletable)
        {
          GError *error = NULL;

          success = gimp_data_factory_data_delete (gimp->palette_factory,
                                                   GIMP_DATA (palette),
                                                   TRUE, &error);

          if (! success)
            {
              g_message (error->message);
              g_clear_error (&error);
            }
        }
      else
        success = FALSE;
    }

  return procedural_db_return_args (proc_record, success);
}

static ProcArg palette_delete_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  }
};

static ProcRecord palette_delete_proc =
{
  "gimp-palette-delete",
  "gimp-palette-delete",
  "Deletes a palette",
  "This procedure deletes a palette",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  1,
  palette_delete_inargs,
  0,
  NULL,
  { { palette_delete_invoker } }
};

static Argument *
palette_is_editable_invoker (ProcRecord   *proc_record,
                             Gimp         *gimp,
                             GimpContext  *context,
                             GimpProgress *progress,
                             Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gboolean editable = FALSE;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette)
        editable = GIMP_DATA (palette)->writable;
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_int = editable;

  return return_args;
}

static ProcArg palette_is_editable_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  }
};

static ProcArg palette_is_editable_outargs[] =
{
  {
    GIMP_PDB_INT32,
    "editable",
    "TRUE if the palette can be edited"
  }
};

static ProcRecord palette_is_editable_proc =
{
  "gimp-palette-is-editable",
  "gimp-palette-is-editable",
  "Tests if palette can be edited",
  "Returns TRUE if you have permission to change the palette",
  "Bill Skaggs <weskaggs@primate.ucdavis.edu>",
  "Bill Skaggs",
  "2004",
  NULL,
  GIMP_INTERNAL,
  1,
  palette_is_editable_inargs,
  1,
  palette_is_editable_outargs,
  { { palette_is_editable_invoker } }
};

static Argument *
palette_get_info_invoker (ProcRecord   *proc_record,
                          Gimp         *gimp,
                          GimpContext  *context,
                          GimpProgress *progress,
                          Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gint32 num_colors = 0;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette)
        num_colors = palette->n_colors;
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_int = num_colors;

  return return_args;
}

static ProcArg palette_get_info_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  }
};

static ProcArg palette_get_info_outargs[] =
{
  {
    GIMP_PDB_INT32,
    "num-colors",
    "The number of colors in the palette"
  }
};

static ProcRecord palette_get_info_proc =
{
  "gimp-palette-get-info",
  "gimp-palette-get-info",
  "Retrieve information about the specified palette.",
  "This procedure retrieves information about the specified palette. This includes the name, and the number of colors.",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  1,
  palette_get_info_inargs,
  1,
  palette_get_info_outargs,
  { { palette_get_info_invoker } }
};

static Argument *
palette_get_columns_invoker (ProcRecord   *proc_record,
                             Gimp         *gimp,
                             GimpContext  *context,
                             GimpProgress *progress,
                             Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gint32 num_columns = 0;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette)
        num_columns = palette->n_columns;
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_int = num_columns;

  return return_args;
}

static ProcArg palette_get_columns_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  }
};

static ProcArg palette_get_columns_outargs[] =
{
  {
    GIMP_PDB_INT32,
    "num-columns",
    "The number of columns used to display this palette"
  }
};

static ProcRecord palette_get_columns_proc =
{
  "gimp-palette-get-columns",
  "gimp-palette-get-columns",
  "Retrieves the number of columns to use to display this palette",
  "This procedures retrieves the prefered number of columns to use when the palette is being displayed.",
  "Sven Neumann <sven@gimp.org>",
  "Sven Neumann",
  "2005",
  NULL,
  GIMP_INTERNAL,
  1,
  palette_get_columns_inargs,
  1,
  palette_get_columns_outargs,
  { { palette_get_columns_invoker } }
};

static Argument *
palette_set_columns_invoker (ProcRecord   *proc_record,
                             Gimp         *gimp,
                             GimpContext  *context,
                             GimpProgress *progress,
                             Argument     *args)
{
  gboolean success = TRUE;
  gchar *name;
  gint32 columns;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  columns = args[1].value.pdb_int;
  if (columns < 0 || columns > 64)
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette && GIMP_DATA (palette)->writable)
        gimp_palette_set_columns (palette, columns);
      else
        success = FALSE;
    }

  return procedural_db_return_args (proc_record, success);
}

static ProcArg palette_set_columns_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_INT32,
    "columns",
    "The new number of columns"
  }
};

static ProcRecord palette_set_columns_proc =
{
  "gimp-palette-set-columns",
  "gimp-palette-set-columns",
  "Sets the number of columns to use when displaying the palette",
  "This procedures allows to control how many colors are shown per row when the palette is being displayed. This value can only be changed if the palette is writable. The maximum allowed value is 64.",
  "Sven Neumann <sven@gimp.org>",
  "Sven Neumann",
  "2005",
  NULL,
  GIMP_INTERNAL,
  2,
  palette_set_columns_inargs,
  0,
  NULL,
  { { palette_set_columns_invoker } }
};

static Argument *
palette_add_entry_invoker (ProcRecord   *proc_record,
                           Gimp         *gimp,
                           GimpContext  *context,
                           GimpProgress *progress,
                           Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gchar *entry_name;
  GimpRGB color;
  gint32 entry_num = 0;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  entry_name = (gchar *) args[1].value.pdb_pointer;
  if (entry_name && !g_utf8_validate (entry_name, -1, NULL))
    success = FALSE;

  color = args[2].value.pdb_color;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette && GIMP_DATA (palette)->writable)
        {
          GimpPaletteEntry *entry =
            gimp_palette_add_entry (palette, -1, entry_name, &color);

          entry_num = entry->position;
        }
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_int = entry_num;

  return return_args;
}

static ProcArg palette_add_entry_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_STRING,
    "entry-name",
    "The name of the entry"
  },
  {
    GIMP_PDB_COLOR,
    "color",
    "The new entry's color color"
  }
};

static ProcArg palette_add_entry_outargs[] =
{
  {
    GIMP_PDB_INT32,
    "entry-num",
    "The index of the added entry"
  }
};

static ProcRecord palette_add_entry_proc =
{
  "gimp-palette-add-entry",
  "gimp-palette-add-entry",
  "Adds a palette entry to the specified palette.",
  "This procedure adds an entry to the specifed palette. It returns an error if the entry palette does not exist.",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  3,
  palette_add_entry_inargs,
  1,
  palette_add_entry_outargs,
  { { palette_add_entry_invoker } }
};

static Argument *
palette_delete_entry_invoker (ProcRecord   *proc_record,
                              Gimp         *gimp,
                              GimpContext  *context,
                              GimpProgress *progress,
                              Argument     *args)
{
  gboolean success = TRUE;
  gchar *name;
  gint32 entry_num;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  entry_num = args[1].value.pdb_int;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette && GIMP_DATA (palette)->writable)
        {
          if (entry_num >= 0 && entry_num < palette->n_colors)
            {
              GimpPaletteEntry *entry = g_list_nth_data (palette->colors, entry_num);

              gimp_palette_delete_entry (palette, entry);
            }
          else
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return procedural_db_return_args (proc_record, success);
}

static ProcArg palette_delete_entry_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_INT32,
    "entry-num",
    "The index of the added entry"
  }
};

static ProcRecord palette_delete_entry_proc =
{
  "gimp-palette-delete-entry",
  "gimp-palette-delete-entry",
  "Deletes a palette entry from the specified palette.",
  "This procedure deletes an entry from the specifed palette. It returns an error if the entry palette does not exist.",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  2,
  palette_delete_entry_inargs,
  0,
  NULL,
  { { palette_delete_entry_invoker } }
};

static Argument *
palette_entry_get_color_invoker (ProcRecord   *proc_record,
                                 Gimp         *gimp,
                                 GimpContext  *context,
                                 GimpProgress *progress,
                                 Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gint32 entry_num;
  GimpRGB color = { 0.0, 0.0, 0.0, 1.0 };

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  entry_num = args[1].value.pdb_int;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette)
        {
          if (entry_num >= 0 && entry_num < palette->n_colors)
            {
              GimpPaletteEntry *entry = g_list_nth_data (palette->colors, entry_num);

              color = entry->color;
            }
          else
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_color = color;

  return return_args;
}

static ProcArg palette_entry_get_color_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_INT32,
    "entry-num",
    "The entry to retrieve"
  }
};

static ProcArg palette_entry_get_color_outargs[] =
{
  {
    GIMP_PDB_COLOR,
    "color",
    "The color requested"
  }
};

static ProcRecord palette_entry_get_color_proc =
{
  "gimp-palette-entry-get-color",
  "gimp-palette-entry-get-color",
  "Gets the specified palette entry from the specified palette.",
  "This procedure retrieves the color of the zero-based entry specifed for the specified palette. It returns an error if the entry does not exist.",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  2,
  palette_entry_get_color_inargs,
  1,
  palette_entry_get_color_outargs,
  { { palette_entry_get_color_invoker } }
};

static Argument *
palette_entry_set_color_invoker (ProcRecord   *proc_record,
                                 Gimp         *gimp,
                                 GimpContext  *context,
                                 GimpProgress *progress,
                                 Argument     *args)
{
  gboolean success = TRUE;
  gchar *name;
  gint32 entry_num;
  GimpRGB color;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  entry_num = args[1].value.pdb_int;

  color = args[2].value.pdb_color;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette && GIMP_DATA (palette)->writable)
        {
          if (entry_num >= 0 && entry_num < palette->n_colors)
            {
              GimpPaletteEntry *entry = g_list_nth_data (palette->colors, entry_num);

              entry->color = color;

              gimp_data_dirty (GIMP_DATA (palette));
            }
          else
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return procedural_db_return_args (proc_record, success);
}

static ProcArg palette_entry_set_color_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_INT32,
    "entry-num",
    "The entry to retrieve"
  },
  {
    GIMP_PDB_COLOR,
    "color",
    "The new color"
  }
};

static ProcRecord palette_entry_set_color_proc =
{
  "gimp-palette-entry-set-color",
  "gimp-palette-entry-set-color",
  "Sets the specified palette entry in the specified palette.",
  "This procedure sets the color of the zero-based entry specifed for the specified palette. It returns an error if the entry does not exist.",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  3,
  palette_entry_set_color_inargs,
  0,
  NULL,
  { { palette_entry_set_color_invoker } }
};

static Argument *
palette_entry_get_name_invoker (ProcRecord   *proc_record,
                                Gimp         *gimp,
                                GimpContext  *context,
                                GimpProgress *progress,
                                Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_args;
  gchar *name;
  gint32 entry_num;
  gchar *entry_name = NULL;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  entry_num = args[1].value.pdb_int;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette)
        {
          if (entry_num >= 0 && entry_num < palette->n_colors)
            {
              GimpPaletteEntry *entry = g_list_nth_data (palette->colors, entry_num);

              entry_name = g_strdup (entry->name);
            }
          else
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return_args = procedural_db_return_args (proc_record, success);

  if (success)
    return_args[1].value.pdb_pointer = entry_name;

  return return_args;
}

static ProcArg palette_entry_get_name_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_INT32,
    "entry-num",
    "The entry to retrieve"
  }
};

static ProcArg palette_entry_get_name_outargs[] =
{
  {
    GIMP_PDB_STRING,
    "entry-name",
    "The name requested"
  }
};

static ProcRecord palette_entry_get_name_proc =
{
  "gimp-palette-entry-get-name",
  "gimp-palette-entry-get-name",
  "Gets the specified palette entry from the specified palette.",
  "This procedure retrieves the name of the zero-based entry specifed for the specified palette. It returns an error if the entry does not exist.",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  2,
  palette_entry_get_name_inargs,
  1,
  palette_entry_get_name_outargs,
  { { palette_entry_get_name_invoker } }
};

static Argument *
palette_entry_set_name_invoker (ProcRecord   *proc_record,
                                Gimp         *gimp,
                                GimpContext  *context,
                                GimpProgress *progress,
                                Argument     *args)
{
  gboolean success = TRUE;
  gchar *name;
  gint32 entry_num;
  gchar *entry_name;

  name = (gchar *) args[0].value.pdb_pointer;
  if (name == NULL || !g_utf8_validate (name, -1, NULL))
    success = FALSE;

  entry_num = args[1].value.pdb_int;

  entry_name = (gchar *) args[2].value.pdb_pointer;
  if (entry_name && !g_utf8_validate (entry_name, -1, NULL))
    success = FALSE;

  if (success)
    {
      GimpPalette *palette = (GimpPalette *)
        gimp_container_get_child_by_name (gimp->palette_factory->container, name);

      if (palette && GIMP_DATA (palette)->writable)
        {
          if (entry_num >= 0 && entry_num < palette->n_colors)
            {
              GimpPaletteEntry *entry = g_list_nth_data (palette->colors, entry_num);

              g_free (entry->name);
              entry->name = g_strdup (entry_name);

              gimp_data_dirty (GIMP_DATA (palette));
            }
          else
            success = FALSE;
        }
      else
        success = FALSE;
    }

  return procedural_db_return_args (proc_record, success);
}

static ProcArg palette_entry_set_name_inargs[] =
{
  {
    GIMP_PDB_STRING,
    "name",
    "The palette name"
  },
  {
    GIMP_PDB_INT32,
    "entry-num",
    "The entry to retrieve"
  },
  {
    GIMP_PDB_STRING,
    "entry-name",
    "The new name"
  }
};

static ProcRecord palette_entry_set_name_proc =
{
  "gimp-palette-entry-set-name",
  "gimp-palette-entry-set-name",
  "Sets the specified palette entry in the specified palette.",
  "This procedure sets the name of the zero-based entry specifed for the specified palette. It returns an error if the entry does not exist.",
  "Michael Natterer <mitch@gimp.org>",
  "Michael Natterer",
  "2004",
  NULL,
  GIMP_INTERNAL,
  3,
  palette_entry_set_name_inargs,
  0,
  NULL,
  { { palette_entry_set_name_invoker } }
};
