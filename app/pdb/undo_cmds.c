/* The GIMP -- an image manipulation program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/* NOTE: This file is autogenerated by pdbgen.pl. */

#include "config.h"


#include <glib-object.h>

#include "pdb-types.h"
#include "procedural_db.h"
#include "core/gimpparamspecs.h"

#include "core/gimp.h"
#include "core/gimpimage-undo.h"
#include "core/gimpimage.h"
#include "plug-in/plug-in.h"

static ProcRecord image_undo_group_start_proc;
static ProcRecord image_undo_group_end_proc;
static ProcRecord image_undo_is_enabled_proc;
static ProcRecord image_undo_disable_proc;
static ProcRecord image_undo_enable_proc;
static ProcRecord image_undo_freeze_proc;
static ProcRecord image_undo_thaw_proc;

void
register_undo_procs (Gimp *gimp)
{
  /*
   * image_undo_group_start
   */
  procedural_db_init_proc (&image_undo_group_start_proc, 1, 0);
  procedural_db_add_argument (&image_undo_group_start_proc,
                              GIMP_PDB_IMAGE,
                              gimp_param_spec_image_id ("image",
                                                        "image",
                                                        "The ID of the image in which to open an undo group",
                                                        gimp,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, &image_undo_group_start_proc);

  /*
   * image_undo_group_end
   */
  procedural_db_init_proc (&image_undo_group_end_proc, 1, 0);
  procedural_db_add_argument (&image_undo_group_end_proc,
                              GIMP_PDB_IMAGE,
                              gimp_param_spec_image_id ("image",
                                                        "image",
                                                        "The ID of the image in which to close an undo group",
                                                        gimp,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, &image_undo_group_end_proc);

  /*
   * image_undo_is_enabled
   */
  procedural_db_init_proc (&image_undo_is_enabled_proc, 1, 1);
  procedural_db_add_argument (&image_undo_is_enabled_proc,
                              GIMP_PDB_IMAGE,
                              gimp_param_spec_image_id ("image",
                                                        "image",
                                                        "The image",
                                                        gimp,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_add_return_value (&image_undo_is_enabled_proc,
                                  GIMP_PDB_INT32,
                                  g_param_spec_boolean ("enabled",
                                                        "enabled",
                                                        "TRUE if undo is enabled for this image",
                                                        FALSE,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, &image_undo_is_enabled_proc);

  /*
   * image_undo_disable
   */
  procedural_db_init_proc (&image_undo_disable_proc, 1, 1);
  procedural_db_add_argument (&image_undo_disable_proc,
                              GIMP_PDB_IMAGE,
                              gimp_param_spec_image_id ("image",
                                                        "image",
                                                        "The image",
                                                        gimp,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_add_return_value (&image_undo_disable_proc,
                                  GIMP_PDB_INT32,
                                  g_param_spec_boolean ("disabled",
                                                        "disabled",
                                                        "TRUE if the image undo has been disabled",
                                                        FALSE,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, &image_undo_disable_proc);

  /*
   * image_undo_enable
   */
  procedural_db_init_proc (&image_undo_enable_proc, 1, 1);
  procedural_db_add_argument (&image_undo_enable_proc,
                              GIMP_PDB_IMAGE,
                              gimp_param_spec_image_id ("image",
                                                        "image",
                                                        "The image",
                                                        gimp,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_add_return_value (&image_undo_enable_proc,
                                  GIMP_PDB_INT32,
                                  g_param_spec_boolean ("enabled",
                                                        "enabled",
                                                        "TRUE if the image undo has been enabled",
                                                        FALSE,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, &image_undo_enable_proc);

  /*
   * image_undo_freeze
   */
  procedural_db_init_proc (&image_undo_freeze_proc, 1, 1);
  procedural_db_add_argument (&image_undo_freeze_proc,
                              GIMP_PDB_IMAGE,
                              gimp_param_spec_image_id ("image",
                                                        "image",
                                                        "The image",
                                                        gimp,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_add_return_value (&image_undo_freeze_proc,
                                  GIMP_PDB_INT32,
                                  g_param_spec_boolean ("frozen",
                                                        "frozen",
                                                        "TRUE if the image undo has been frozen",
                                                        FALSE,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, &image_undo_freeze_proc);

  /*
   * image_undo_thaw
   */
  procedural_db_init_proc (&image_undo_thaw_proc, 1, 1);
  procedural_db_add_argument (&image_undo_thaw_proc,
                              GIMP_PDB_IMAGE,
                              gimp_param_spec_image_id ("image",
                                                        "image",
                                                        "The image",
                                                        gimp,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_add_return_value (&image_undo_thaw_proc,
                                  GIMP_PDB_INT32,
                                  g_param_spec_boolean ("thawed",
                                                        "thawed",
                                                        "TRUE if the image undo has been thawed",
                                                        FALSE,
                                                        GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, &image_undo_thaw_proc);

}

static Argument *
image_undo_group_start_invoker (ProcRecord   *proc_record,
                                Gimp         *gimp,
                                GimpContext  *context,
                                GimpProgress *progress,
                                Argument     *args)
{
  gboolean success = TRUE;
  GimpImage *image;

  image = gimp_image_get_by_ID (gimp, args[0].value.pdb_int);
  if (! GIMP_IS_IMAGE (image))
    success = FALSE;

  if (success)
    {
      gchar *undo_desc = NULL;

      if (gimp->current_plug_in)
        undo_desc = plug_in_get_undo_desc (gimp->current_plug_in);

      gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_MISC, undo_desc);

      if (undo_desc)
        g_free (undo_desc);
    }

  return procedural_db_return_values (proc_record, success);
}

static ProcRecord image_undo_group_start_proc =
{
  "gimp-image-undo-group-start",
  "gimp-image-undo-group-start",
  "Starts a group undo.",
  "This function is used to start a group undo--necessary for logically combining two or more undo operations into a single operation. This call must be used in conjunction with a 'gimp-image-undo-group-end' call.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1997",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_group_start_invoker } }
};

static Argument *
image_undo_group_end_invoker (ProcRecord   *proc_record,
                              Gimp         *gimp,
                              GimpContext  *context,
                              GimpProgress *progress,
                              Argument     *args)
{
  gboolean success = TRUE;
  GimpImage *image;

  image = gimp_image_get_by_ID (gimp, args[0].value.pdb_int);
  if (! GIMP_IS_IMAGE (image))
    success = FALSE;

  if (success)
    {
      gimp_image_undo_group_end (image);
    }

  return procedural_db_return_values (proc_record, success);
}

static ProcRecord image_undo_group_end_proc =
{
  "gimp-image-undo-group-end",
  "gimp-image-undo-group-end",
  "Finish a group undo.",
  "This function must be called once for each 'gimp-image-undo-group-start' call that is made.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1997",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_group_end_invoker } }
};

static Argument *
image_undo_is_enabled_invoker (ProcRecord   *proc_record,
                               Gimp         *gimp,
                               GimpContext  *context,
                               GimpProgress *progress,
                               Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_vals;
  GimpImage *image;
  gboolean enabled = FALSE;

  image = gimp_image_get_by_ID (gimp, args[0].value.pdb_int);
  if (! GIMP_IS_IMAGE (image))
    success = FALSE;

  if (success)
    {
      enabled = gimp_image_undo_is_enabled (image);
    }

  return_vals = procedural_db_return_values (proc_record, success);

  if (success)
    return_vals[1].value.pdb_int = enabled;

  return return_vals;
}

static ProcRecord image_undo_is_enabled_proc =
{
  "gimp-image-undo-is-enabled",
  "gimp-image-undo-is-enabled",
  "Check if the image's undo stack is enabled.",
  "This procedure checks if the image's undo stack is currently enabled or disabled. This is useful when several plugins or scripts call each other and want to check if their caller has already used 'gimp_image_undo_disable' or 'gimp_image_undo_freeze'.",
  "Raphael Quinet",
  "Raphael Quinet",
  "1999",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_is_enabled_invoker } }
};

static Argument *
image_undo_disable_invoker (ProcRecord   *proc_record,
                            Gimp         *gimp,
                            GimpContext  *context,
                            GimpProgress *progress,
                            Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_vals;
  GimpImage *image;
  gboolean disabled = FALSE;

  image = gimp_image_get_by_ID (gimp, args[0].value.pdb_int);
  if (! GIMP_IS_IMAGE (image))
    success = FALSE;

  if (success)
    {
      disabled = gimp_image_undo_disable (image);
    }

  return_vals = procedural_db_return_values (proc_record, success);

  if (success)
    return_vals[1].value.pdb_int = disabled;

  return return_vals;
}

static ProcRecord image_undo_disable_proc =
{
  "gimp-image-undo-disable",
  "gimp-image-undo-disable",
  "Disable the image's undo stack.",
  "This procedure disables the image's undo stack, allowing subsequent operations to ignore their undo steps. This is generally called in conjunction with 'gimp_image_undo_enable' to temporarily disable an image undo stack. This is advantageous because saving undo steps can be time and memory intensive.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1995-1996",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_disable_invoker } }
};

static Argument *
image_undo_enable_invoker (ProcRecord   *proc_record,
                           Gimp         *gimp,
                           GimpContext  *context,
                           GimpProgress *progress,
                           Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_vals;
  GimpImage *image;
  gboolean enabled = FALSE;

  image = gimp_image_get_by_ID (gimp, args[0].value.pdb_int);
  if (! GIMP_IS_IMAGE (image))
    success = FALSE;

  if (success)
    {
      enabled = gimp_image_undo_enable (image);
    }

  return_vals = procedural_db_return_values (proc_record, success);

  if (success)
    return_vals[1].value.pdb_int = enabled;

  return return_vals;
}

static ProcRecord image_undo_enable_proc =
{
  "gimp-image-undo-enable",
  "gimp-image-undo-enable",
  "Enable the image's undo stack.",
  "This procedure enables the image's undo stack, allowing subsequent operations to store their undo steps. This is generally called in conjunction with 'gimp_image_undo_disable' to temporarily disable an image undo stack.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1995-1996",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_enable_invoker } }
};

static Argument *
image_undo_freeze_invoker (ProcRecord   *proc_record,
                           Gimp         *gimp,
                           GimpContext  *context,
                           GimpProgress *progress,
                           Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_vals;
  GimpImage *image;
  gboolean frozen = FALSE;

  image = gimp_image_get_by_ID (gimp, args[0].value.pdb_int);
  if (! GIMP_IS_IMAGE (image))
    success = FALSE;

  if (success)
    {
      frozen = gimp_image_undo_freeze (image);
    }

  return_vals = procedural_db_return_values (proc_record, success);

  if (success)
    return_vals[1].value.pdb_int = frozen;

  return return_vals;
}

static ProcRecord image_undo_freeze_proc =
{
  "gimp-image-undo-freeze",
  "gimp-image-undo-freeze",
  "Freeze the image's undo stack.",
  "This procedure freezes the image's undo stack, allowing subsequent operations to ignore their undo steps. This is generally called in conjunction with 'gimp_image_undo_thaw' to temporarily disable an image undo stack. This is advantageous because saving undo steps can be time and memory intensive. 'gimp_image_undo_{freeze,thaw}' and 'gimp_image_undo_{disable,enable}' differ in that the former does not free up all undo steps when undo is thawed, so is more suited to interactive in-situ previews. It is important in this case that the image is back to the same state it was frozen in before thawing, else 'undo' behaviour is undefined.",
  "Adam D. Moss",
  "Adam D. Moss",
  "1999",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_freeze_invoker } }
};

static Argument *
image_undo_thaw_invoker (ProcRecord   *proc_record,
                         Gimp         *gimp,
                         GimpContext  *context,
                         GimpProgress *progress,
                         Argument     *args)
{
  gboolean success = TRUE;
  Argument *return_vals;
  GimpImage *image;
  gboolean thawed = FALSE;

  image = gimp_image_get_by_ID (gimp, args[0].value.pdb_int);
  if (! GIMP_IS_IMAGE (image))
    success = FALSE;

  if (success)
    {
      thawed = gimp_image_undo_thaw (image);
    }

  return_vals = procedural_db_return_values (proc_record, success);

  if (success)
    return_vals[1].value.pdb_int = thawed;

  return return_vals;
}

static ProcRecord image_undo_thaw_proc =
{
  "gimp-image-undo-thaw",
  "gimp-image-undo-thaw",
  "Thaw the image's undo stack.",
  "This procedure thaws the image's undo stack, allowing subsequent operations to store their undo steps. This is generally called in conjunction with 'gimp_image_undo_freeze' to temporarily freeze an image undo stack. 'gimp_image_undo_thaw' does NOT free the undo stack as 'gimp_image_undo_enable' does, so is suited for situations where one wishes to leave the undo stack in the same state in which one found it despite non-destructively playing with the image in the meantime. An example would be in-situ plugin previews. Balancing freezes and thaws and ensuring image consistancy is the responsibility of the caller.",
  "Adam D. Moss",
  "Adam D. Moss",
  "1999",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_thaw_invoker } }
};
