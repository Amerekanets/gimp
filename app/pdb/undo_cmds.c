/* The GIMP -- an image manipulation program
 * Copyright (C) 1995-2003 Spencer Kimball and Peter Mattis
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/* NOTE: This file is autogenerated by pdbgen.pl. */

#include "config.h"


#include <glib-object.h>

#include "pdb-types.h"
#include "gimpargument.h"
#include "gimpprocedure.h"
#include "procedural_db.h"
#include "core/gimpparamspecs.h"

#include "core/gimp.h"
#include "core/gimpimage-undo.h"
#include "core/gimpimage.h"
#include "plug-in/plug-in.h"

static GimpProcedure image_undo_group_start_proc;
static GimpProcedure image_undo_group_end_proc;
static GimpProcedure image_undo_is_enabled_proc;
static GimpProcedure image_undo_disable_proc;
static GimpProcedure image_undo_enable_proc;
static GimpProcedure image_undo_freeze_proc;
static GimpProcedure image_undo_thaw_proc;

void
register_undo_procs (Gimp *gimp)
{
  GimpProcedure *procedure;

  /*
   * image_undo_group_start
   */
  procedure = gimp_procedure_init (&image_undo_group_start_proc, 1, 0);
  gimp_procedure_add_argument (procedure,
                               GIMP_PDB_IMAGE,
                               gimp_param_spec_image_id ("image",
                                                         "image",
                                                         "The ID of the image in which to open an undo group",
                                                         gimp,
                                                         GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, procedure);

  /*
   * image_undo_group_end
   */
  procedure = gimp_procedure_init (&image_undo_group_end_proc, 1, 0);
  gimp_procedure_add_argument (procedure,
                               GIMP_PDB_IMAGE,
                               gimp_param_spec_image_id ("image",
                                                         "image",
                                                         "The ID of the image in which to close an undo group",
                                                         gimp,
                                                         GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, procedure);

  /*
   * image_undo_is_enabled
   */
  procedure = gimp_procedure_init (&image_undo_is_enabled_proc, 1, 1);
  gimp_procedure_add_argument (procedure,
                               GIMP_PDB_IMAGE,
                               gimp_param_spec_image_id ("image",
                                                         "image",
                                                         "The image",
                                                         gimp,
                                                         GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   GIMP_PDB_INT32,
                                   g_param_spec_boolean ("enabled",
                                                         "enabled",
                                                         "TRUE if undo is enabled for this image",
                                                         FALSE,
                                                         GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, procedure);

  /*
   * image_undo_disable
   */
  procedure = gimp_procedure_init (&image_undo_disable_proc, 1, 1);
  gimp_procedure_add_argument (procedure,
                               GIMP_PDB_IMAGE,
                               gimp_param_spec_image_id ("image",
                                                         "image",
                                                         "The image",
                                                         gimp,
                                                         GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   GIMP_PDB_INT32,
                                   g_param_spec_boolean ("disabled",
                                                         "disabled",
                                                         "TRUE if the image undo has been disabled",
                                                         FALSE,
                                                         GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, procedure);

  /*
   * image_undo_enable
   */
  procedure = gimp_procedure_init (&image_undo_enable_proc, 1, 1);
  gimp_procedure_add_argument (procedure,
                               GIMP_PDB_IMAGE,
                               gimp_param_spec_image_id ("image",
                                                         "image",
                                                         "The image",
                                                         gimp,
                                                         GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   GIMP_PDB_INT32,
                                   g_param_spec_boolean ("enabled",
                                                         "enabled",
                                                         "TRUE if the image undo has been enabled",
                                                         FALSE,
                                                         GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, procedure);

  /*
   * image_undo_freeze
   */
  procedure = gimp_procedure_init (&image_undo_freeze_proc, 1, 1);
  gimp_procedure_add_argument (procedure,
                               GIMP_PDB_IMAGE,
                               gimp_param_spec_image_id ("image",
                                                         "image",
                                                         "The image",
                                                         gimp,
                                                         GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   GIMP_PDB_INT32,
                                   g_param_spec_boolean ("frozen",
                                                         "frozen",
                                                         "TRUE if the image undo has been frozen",
                                                         FALSE,
                                                         GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, procedure);

  /*
   * image_undo_thaw
   */
  procedure = gimp_procedure_init (&image_undo_thaw_proc, 1, 1);
  gimp_procedure_add_argument (procedure,
                               GIMP_PDB_IMAGE,
                               gimp_param_spec_image_id ("image",
                                                         "image",
                                                         "The image",
                                                         gimp,
                                                         GIMP_PARAM_READWRITE));
  gimp_procedure_add_return_value (procedure,
                                   GIMP_PDB_INT32,
                                   g_param_spec_boolean ("thawed",
                                                         "thawed",
                                                         "TRUE if the image undo has been thawed",
                                                         FALSE,
                                                         GIMP_PARAM_READWRITE));
  procedural_db_register (gimp, procedure);

}

static GimpArgument *
image_undo_group_start_invoker (GimpProcedure *procedure,
                                Gimp          *gimp,
                                GimpContext   *context,
                                GimpProgress  *progress,
                                GimpArgument  *args)
{
  gboolean success = TRUE;
  GimpImage *image;

  image = gimp_value_get_image (&args[0].value, gimp);

  if (success)
    {
      gchar *undo_desc = NULL;

      if (gimp->current_plug_in)
        undo_desc = plug_in_get_undo_desc (gimp->current_plug_in);

      gimp_image_undo_group_start (image, GIMP_UNDO_GROUP_MISC, undo_desc);

      if (undo_desc)
        g_free (undo_desc);
    }

  return gimp_procedure_get_return_values (procedure, success);
}

static GimpProcedure image_undo_group_start_proc =
{
  TRUE, TRUE,
  "gimp-image-undo-group-start",
  "gimp-image-undo-group-start",
  "Starts a group undo.",
  "This function is used to start a group undo--necessary for logically combining two or more undo operations into a single operation. This call must be used in conjunction with a 'gimp-image-undo-group-end' call.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1997",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_group_start_invoker } }
};

static GimpArgument *
image_undo_group_end_invoker (GimpProcedure *procedure,
                              Gimp          *gimp,
                              GimpContext   *context,
                              GimpProgress  *progress,
                              GimpArgument  *args)
{
  gboolean success = TRUE;
  GimpImage *image;

  image = gimp_value_get_image (&args[0].value, gimp);

  if (success)
    {
      gimp_image_undo_group_end (image);
    }

  return gimp_procedure_get_return_values (procedure, success);
}

static GimpProcedure image_undo_group_end_proc =
{
  TRUE, TRUE,
  "gimp-image-undo-group-end",
  "gimp-image-undo-group-end",
  "Finish a group undo.",
  "This function must be called once for each 'gimp-image-undo-group-start' call that is made.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1997",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_group_end_invoker } }
};

static GimpArgument *
image_undo_is_enabled_invoker (GimpProcedure *procedure,
                               Gimp          *gimp,
                               GimpContext   *context,
                               GimpProgress  *progress,
                               GimpArgument  *args)
{
  gboolean success = TRUE;
  GimpArgument *return_vals;
  GimpImage *image;
  gboolean enabled = FALSE;

  image = gimp_value_get_image (&args[0].value, gimp);

  if (success)
    {
      enabled = gimp_image_undo_is_enabled (image);
    }

  return_vals = gimp_procedure_get_return_values (procedure, success);

  if (success)
    g_value_set_boolean (&return_vals[1].value, enabled);

  return return_vals;
}

static GimpProcedure image_undo_is_enabled_proc =
{
  TRUE, TRUE,
  "gimp-image-undo-is-enabled",
  "gimp-image-undo-is-enabled",
  "Check if the image's undo stack is enabled.",
  "This procedure checks if the image's undo stack is currently enabled or disabled. This is useful when several plugins or scripts call each other and want to check if their caller has already used 'gimp_image_undo_disable' or 'gimp_image_undo_freeze'.",
  "Raphael Quinet",
  "Raphael Quinet",
  "1999",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_is_enabled_invoker } }
};

static GimpArgument *
image_undo_disable_invoker (GimpProcedure *procedure,
                            Gimp          *gimp,
                            GimpContext   *context,
                            GimpProgress  *progress,
                            GimpArgument  *args)
{
  gboolean success = TRUE;
  GimpArgument *return_vals;
  GimpImage *image;
  gboolean disabled = FALSE;

  image = gimp_value_get_image (&args[0].value, gimp);

  if (success)
    {
      disabled = gimp_image_undo_disable (image);
    }

  return_vals = gimp_procedure_get_return_values (procedure, success);

  if (success)
    g_value_set_boolean (&return_vals[1].value, disabled);

  return return_vals;
}

static GimpProcedure image_undo_disable_proc =
{
  TRUE, TRUE,
  "gimp-image-undo-disable",
  "gimp-image-undo-disable",
  "Disable the image's undo stack.",
  "This procedure disables the image's undo stack, allowing subsequent operations to ignore their undo steps. This is generally called in conjunction with 'gimp_image_undo_enable' to temporarily disable an image undo stack. This is advantageous because saving undo steps can be time and memory intensive.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1995-1996",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_disable_invoker } }
};

static GimpArgument *
image_undo_enable_invoker (GimpProcedure *procedure,
                           Gimp          *gimp,
                           GimpContext   *context,
                           GimpProgress  *progress,
                           GimpArgument  *args)
{
  gboolean success = TRUE;
  GimpArgument *return_vals;
  GimpImage *image;
  gboolean enabled = FALSE;

  image = gimp_value_get_image (&args[0].value, gimp);

  if (success)
    {
      enabled = gimp_image_undo_enable (image);
    }

  return_vals = gimp_procedure_get_return_values (procedure, success);

  if (success)
    g_value_set_boolean (&return_vals[1].value, enabled);

  return return_vals;
}

static GimpProcedure image_undo_enable_proc =
{
  TRUE, TRUE,
  "gimp-image-undo-enable",
  "gimp-image-undo-enable",
  "Enable the image's undo stack.",
  "This procedure enables the image's undo stack, allowing subsequent operations to store their undo steps. This is generally called in conjunction with 'gimp_image_undo_disable' to temporarily disable an image undo stack.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1995-1996",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_enable_invoker } }
};

static GimpArgument *
image_undo_freeze_invoker (GimpProcedure *procedure,
                           Gimp          *gimp,
                           GimpContext   *context,
                           GimpProgress  *progress,
                           GimpArgument  *args)
{
  gboolean success = TRUE;
  GimpArgument *return_vals;
  GimpImage *image;
  gboolean frozen = FALSE;

  image = gimp_value_get_image (&args[0].value, gimp);

  if (success)
    {
      frozen = gimp_image_undo_freeze (image);
    }

  return_vals = gimp_procedure_get_return_values (procedure, success);

  if (success)
    g_value_set_boolean (&return_vals[1].value, frozen);

  return return_vals;
}

static GimpProcedure image_undo_freeze_proc =
{
  TRUE, TRUE,
  "gimp-image-undo-freeze",
  "gimp-image-undo-freeze",
  "Freeze the image's undo stack.",
  "This procedure freezes the image's undo stack, allowing subsequent operations to ignore their undo steps. This is generally called in conjunction with 'gimp_image_undo_thaw' to temporarily disable an image undo stack. This is advantageous because saving undo steps can be time and memory intensive. 'gimp_image_undo_{freeze,thaw}' and 'gimp_image_undo_{disable,enable}' differ in that the former does not free up all undo steps when undo is thawed, so is more suited to interactive in-situ previews. It is important in this case that the image is back to the same state it was frozen in before thawing, else 'undo' behaviour is undefined.",
  "Adam D. Moss",
  "Adam D. Moss",
  "1999",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_freeze_invoker } }
};

static GimpArgument *
image_undo_thaw_invoker (GimpProcedure *procedure,
                         Gimp          *gimp,
                         GimpContext   *context,
                         GimpProgress  *progress,
                         GimpArgument  *args)
{
  gboolean success = TRUE;
  GimpArgument *return_vals;
  GimpImage *image;
  gboolean thawed = FALSE;

  image = gimp_value_get_image (&args[0].value, gimp);

  if (success)
    {
      thawed = gimp_image_undo_thaw (image);
    }

  return_vals = gimp_procedure_get_return_values (procedure, success);

  if (success)
    g_value_set_boolean (&return_vals[1].value, thawed);

  return return_vals;
}

static GimpProcedure image_undo_thaw_proc =
{
  TRUE, TRUE,
  "gimp-image-undo-thaw",
  "gimp-image-undo-thaw",
  "Thaw the image's undo stack.",
  "This procedure thaws the image's undo stack, allowing subsequent operations to store their undo steps. This is generally called in conjunction with 'gimp_image_undo_freeze' to temporarily freeze an image undo stack. 'gimp_image_undo_thaw' does NOT free the undo stack as 'gimp_image_undo_enable' does, so is suited for situations where one wishes to leave the undo stack in the same state in which one found it despite non-destructively playing with the image in the meantime. An example would be in-situ plugin previews. Balancing freezes and thaws and ensuring image consistancy is the responsibility of the caller.",
  "Adam D. Moss",
  "Adam D. Moss",
  "1999",
  NULL,
  GIMP_INTERNAL,
  0, NULL, 0, NULL,
  { { image_undo_thaw_invoker } }
};
