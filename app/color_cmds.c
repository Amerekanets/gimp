/* The GIMP -- an image manipulation program
 * Copyright (C) 1995-1999 Spencer Kimball and Peter Mattis
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
 */

/* NOTE: This file is autogenerated by pdbgen.pl. */

#include "procedural_db.h"

#include "drawable.h"
#include "gimpdrawable.h"
#include "gimpimage.h"
#include "gimplut.h"
#include "lut_funcs.h"

static ProcRecord brightness_contrast_proc;
static ProcRecord levels_proc;
static ProcRecord posterize_proc;

void
register_color_procs (void)
{
  procedural_db_register (&brightness_contrast_proc);
  procedural_db_register (&levels_proc);
  procedural_db_register (&posterize_proc);
}

static Argument *
brightness_contrast_invoker (Argument *args)
{
  gboolean success = TRUE;
  GimpDrawable *drawable;
  gint32 brightness;
  gint32 contrast;
  GimpImage *gimage;
  GimpLut *lut;
  PixelRegion srcPR, destPR;
  int x1, y1, x2, y2;

  drawable = gimp_drawable_get_ID (args[0].value.pdb_int);
  if (drawable == NULL)
    success = FALSE;

  brightness = args[1].value.pdb_int;
  if (brightness < -127 || brightness > 127)
    success = FALSE;

  contrast = args[2].value.pdb_int;
  if (contrast < -127 || contrast > 127)
    success = FALSE;

  if (success)
    {
      if (gimp_drawable_indexed (drawable))
	success = FALSE;
      else
	{
	  gimage = gimp_drawable_gimage (drawable);
    
	  lut = brightness_contrast_lut_new (brightness / 255.0,
	                                     contrast / 127.0,
	                                     gimp_drawable_bytes (drawable));
    
	  /* The application should occur only within selection bounds */
	  gimp_drawable_mask_bounds (drawable, &x1, &y1, &x2, &y2);
    
	  pixel_region_init (&srcPR, gimp_drawable_data (drawable),
	                     x1, y1, (x2 - x1), (y2 - y1), FALSE);
	  pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
	                     x1, y1, (x2 - x1), (y2 - y1), TRUE);
    
	  pixel_regions_process_parallel ((p_func) gimp_lut_process, lut, 2,
	                                  &srcPR, &destPR);
    
	  gimp_lut_free (lut);
	  gimp_drawable_merge_shadow (drawable, TRUE);
	  drawable_update (drawable, x1, y1, (x2 - x1), (y2 - y1));
	}
    }

  return procedural_db_return_args (&brightness_contrast_proc, success);
}

static ProcArg brightness_contrast_inargs[] =
{
  {
    PDB_DRAWABLE,
    "drawable",
    "The drawable"
  },
  {
    PDB_INT32,
    "brightness",
    "Brightness adjustment: (-127 <= brightness <= 127)"
  },
  {
    PDB_INT32,
    "contrast",
    "Contrast adjustment: (-127 <= contrast <= 127)"
  }
};

static ProcRecord brightness_contrast_proc =
{
  "gimp_brightness_contrast",
  "Modify brightness/contrast in the specified drawable.",
  "This procedures allows the brightness and contrast of the specified drawable to be modified. Both 'brightness' and 'contrast' parameters are defined between -127 and 127.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1997",
  PDB_INTERNAL,
  3,
  brightness_contrast_inargs,
  0,
  NULL,
  { { brightness_contrast_invoker } }
};

static Argument *
levels_invoker (Argument *args)
{
  gboolean success = TRUE;
  GimpDrawable *drawable;
  gint32 channel;
  gint32 low_inputv;
  gint32 high_inputv;
  gdouble gammav;
  gint32 low_outputv;
  gint32 high_outputv;
  PixelRegion srcPR, destPR;
  int x1, y1, x2, y2;
  GimpLut *lut;
  int i;
  int low_input[5];
  int high_input[5];
  double gamma[5];
  int low_output[5];
  int high_output[5];

  drawable = gimp_drawable_get_ID (args[0].value.pdb_int);
  if (drawable == NULL)
    success = FALSE;

  channel = args[1].value.pdb_int;
  if (channel < VALUE_LUT || channel > BLUE_LUT)
    success = FALSE;

  low_inputv = args[2].value.pdb_int;
  if (low_inputv < 0 || low_inputv > 255)
    success = FALSE;

  high_inputv = args[3].value.pdb_int;
  if (high_inputv < 0 || high_inputv > 255)
    success = FALSE;

  gammav = args[4].value.pdb_float;
  if (gammav < 0.1 || gammav > 10.0)
    success = FALSE;

  low_outputv = args[5].value.pdb_int;
  if (low_outputv < 0 || low_outputv > 255)
    success = FALSE;

  high_outputv = args[6].value.pdb_int;
  if (high_outputv < 0 || high_outputv > 255)
    success = FALSE;

  if (success)
    {
      if (gimp_drawable_indexed (drawable) ||
	  (gimp_drawable_gray (drawable) && channel != GRAY))
	success = FALSE;
      else
	{
	  for (i = 0; i < 5; i++)
	    {
	      low_input[i] = 0;
	      high_input[i] = 255;
	      low_output[i] = 0;
	      high_output[i] = 255;
	      gamma[i] = 1.0;
	    }
    
	  low_input[channel] = low_inputv;
	  high_input[channel] = high_inputv;
	  gamma[channel] = gammav;
	  low_output[channel] = low_outputv;
	  high_output[channel] = high_outputv;
    
	  /* setup the lut */
	  lut = levels_lut_new (gamma, low_input, high_input,
	                        low_output, high_output,
	                        gimp_drawable_bytes (drawable));
    
	  /* The application should occur only within selection bounds */
	  gimp_drawable_mask_bounds (drawable, &x1, &y1, &x2, &y2);
    
	  pixel_region_init (&srcPR, gimp_drawable_data (drawable),
	                     x1, y1, (x2 - x1), (y2 - y1), FALSE);
	  pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
	                     x1, y1, (x2 - x1), (y2 - y1), TRUE);
    
	  pixel_regions_process_parallel ((p_func) gimp_lut_process, lut, 2,
	                                  &srcPR, &destPR);
    
	  gimp_lut_free(lut);
	  gimp_drawable_merge_shadow (drawable, TRUE);
	  drawable_update (drawable, x1, y1, (x2 - x1), (y2 - y1));
	}
    }

  return procedural_db_return_args (&levels_proc, success);
}

static ProcArg levels_inargs[] =
{
  {
    PDB_DRAWABLE,
    "drawable",
    "The drawable"
  },
  {
    PDB_INT32,
    "channel",
    "The channel to modify: { VALUE/GRAY (0), RED (1), GREEN (2), BLUE (3) }"
  },
  {
    PDB_INT32,
    "low_input",
    "Intensity of lowest input: (0 <= low_input <= 255)"
  },
  {
    PDB_INT32,
    "high_input",
    "Intensity of highest input: (0 <= high_input <= 255)"
  },
  {
    PDB_FLOAT,
    "gamma",
    "Gamma correction factor: (0.1 <= gamma <= 10)"
  },
  {
    PDB_INT32,
    "low_output",
    "Intensity of lowest output: (0 <= low_output <= 255)"
  },
  {
    PDB_INT32,
    "high_output",
    "Intensity of highest output: (0 <= high_output <= 255)"
  }
};

static ProcRecord levels_proc =
{
  "gimp_levels",
  "Modifies intensity levels in the specified drawable.",
  "This tool allows intensity levels in the specified drawable to be remapped according to a set of parameters. The low/high input levels specify an initial mapping from the source intensities. The gamma value determines how intensities between the low and high input intensities are interpolated. A gamma value of 1.0 results in a linear interpolation. Higher gamma values result in more high-level intensities. Lower gamma values result in more low-level intensities. The low/high output levels constrain the final intensity mapping--that is, no final intensity will be lower than the low output level and no final intensity will be higher than the high output level. This tool is only valid on RGB color and grayscale images. It will not operate on indexed drawables.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1995-1996",
  PDB_INTERNAL,
  7,
  levels_inargs,
  0,
  NULL,
  { { levels_invoker } }
};

static Argument *
posterize_invoker (Argument *args)
{
  gboolean success = TRUE;
  GimpDrawable *drawable;
  gint32 levels;
  GimpImage *gimage;
  GimpLut *lut;
  PixelRegion srcPR, destPR;
  int x1, y1, x2, y2;

  drawable = gimp_drawable_get_ID (args[0].value.pdb_int);
  if (drawable == NULL)
    success = FALSE;

  levels = args[1].value.pdb_int;
  if (levels < 2 || levels > 255)
    success = FALSE;

  if (success)
    {
      if (gimp_drawable_indexed (drawable))
	success = FALSE;
      else
	{
	  gimage = gimp_drawable_gimage (drawable);
    
	  lut = posterize_lut_new (levels, gimp_drawable_bytes (drawable)); 
    
	  /* The application should occur only within selection bounds */
	  gimp_drawable_mask_bounds (drawable, &x1, &y1, &x2, &y2);
    
	  pixel_region_init (&srcPR, gimp_drawable_data (drawable),
	                     x1, y1, (x2 - x1), (y2 - y1), FALSE);
	  pixel_region_init (&destPR, gimp_drawable_shadow (drawable),
	                     x1, y1, (x2 - x1), (y2 - y1), TRUE);
    
	  pixel_regions_process_parallel ((p_func) gimp_lut_process, lut, 2,
	                                  &srcPR, &destPR);
    
	  gimp_lut_free (lut);
	  gimp_drawable_merge_shadow (drawable, TRUE);
	  drawable_update (drawable, x1, y1, (x2 - x1), (y2 - y1));
	}
    }

  return procedural_db_return_args (&posterize_proc, success);
}

static ProcArg posterize_inargs[] =
{
  {
    PDB_DRAWABLE,
    "drawable",
    "The drawable"
  },
  {
    PDB_INT32,
    "levels",
    "Levels of posterization: (2 <= levels <= 255)"
  }
};

static ProcRecord posterize_proc =
{
  "gimp_posterize",
  "Posterize the specified drawable.",
  "This procedures reduces the number of shades allows in each intensity channel to the specified 'levels' parameter.",
  "Spencer Kimball & Peter Mattis",
  "Spencer Kimball & Peter Mattis",
  "1997",
  PDB_INTERNAL,
  2,
  posterize_inargs,
  0,
  NULL,
  { { posterize_invoker } }
};
